"Object-oriented" and "functional" programming styles have often been cast as
opposing, but "polymorphism and late-binding" (the definition of
object-oriented programming) does not preclude "programming without side
effects" (the definition of functional programming). How do these styles of
program design complement each other in the small and in the large?

for data (which has scope that you can't control) that can't be snapshotted and
synchronized efficiently you must use reference semantics, which imply:
=> mutability 
=> concurrent (as opposed to parallel) abstractions 
=> integration testing 
=> small, specific, opaque interfaces with little surface area (cf posix file api?) 
=> late-binding, dynamic, "framework" code
=> amenable to interactive development (repl-driven, live-coding)
=> stateful testing (even poking at a live system)
=> high-level organization is critical
=> encapsulation is critical

for everything else, you can use value semantics, which imply:
=> immutability 
=> parallel (as opposed to concurrent) abstractions 
=> unit testing 
=> large, general, transparent interfaces with lots of surface area (cf clojure collections, numeric & scientific code) 
=> early-binding, static, "library" code
=> amenable to static analyses (type-driven)
=> stateless testing
=> very little high-level organization required
=> encapsulation isn't important
  - cf Joe Armstrong on global scope for all functions
  - cf Hoogle

reference semantics are about scope
there's data from the outside world whose scope you don't control
as object oriented programmers, we know this! ex. pervasive defensive copying

oo is about interfaces and organization - late-binding meaning "the invocation
of a procedure without knowing what code will be called at runtime". whether
explicit (Java) or implicit (Python) the idea of having a common "interface" to
a group of "objects" is key to making this work.

objects are inevitable because having some structured way of doing indirection
& late binding is necessary for building frameworks
  - are frameworks necessary?
    - frameworkless web development

fp is about avoiding side-effects

The immutable machine.

> Let me conclude. Automatic computers have now been with us for a quarter of a
> century. They have had a great impact on our society in their capacity of
> tools, but in that capacity their influence will be but a ripple on the
> surface of our culture, compared with the much more profound influence they
> will have in their capacity of intellectual challenge without precedent in
> the cultural history of mankind. Hierarchical systems seem to have the
> property that something considered as an undivided entity on one level, is
> considered as a composite object on the next lower level of greater detail;
> as a result the natural grain of space or time that is applicable at each
> level decreases by an order of magnitude when we shift our attention from one
> level to the next lower one. We understand walls in terms of bricks, bricks
> in terms of crystals, crystals in terms of molecules etc. As a result the
> number of levels that can be distinguished meaningfully in a hierarchical
> system is kind of proportional to the logarithm of the ratio between the
> largest and the smallest grain, and therefore, unless this ratio is very
> large, we cannot expect many levels. In computer programming our basic
> building block has an associated time grain of less than a microsecond, but
> our program may take hours of computation time. I do not know of any other
> technology covering a ratio of 1010 or more: the computer, by virtue of its
> fantastic speed, seems to be the first to provide us with an environment
> where highly hierarchical artefacts are both possible and necessary. This
> challenge, viz. the confrontation with the programming task, is so unique
> that this novel experience can teach us a lot about ourselves. It should
> deepen our understanding of the processes of design and creation, it should
> give us better control over the task of organizing our thoughts. If it did
> not do so, to my taste we should not deserve the computer at all!

> And I have a word for this or a term for this which I call, PLOP.
> PLace-Oriented Programming, which is what this is and you can tell when it's
> going on because anytime new information replaces old information, you're
> doing Place-Oriented Programming. There's a reason we do Place-Oriented
> Programming because way back in the early days of computers, we had to do
> Place-Oriented Programming. I saw Guy Steele give a great talk where he was
> talking about working, you know, building these systems on a computer that
> had four kilowords of memory. In every piece of memory, you knew the address,
> you knew the even number addresses starting at 2000 were used for jump table
> and these other addresses over here where used for data, and other parts of
> the addresses were used for code. Sometimes they were used for more than one
> thing because you knew, like right now, no one's using this for codes so we
> can use it for data and vice versa. You had to do it. There wasn't enough
> capacity to do anything else. Computer memories were really small. Disks were
> very small. Everything was very expensive. So we adopted an approach to
> programming that was based around the manipulation of places. It totally made
> sense. And the keyword there, the key aspect to that is it made sense. It
> used to make sense. Those limitations are gone. In the time that I've been
> doing programming, the capacity of these two things have increased a
> millionfold. A millionfold. What other thing in life you know has the same
> facts about it remain true when the size of something changes by a
> millionfold. Imagine if your car was a million times bigger than it is. What
> rules would still apply? What characteristics would still be true? Almost
> nothing but yet, we're retaining decisions we made when things were much much
> smaller and moving forward with it.
